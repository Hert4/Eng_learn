Vấn đề bạn mô tả là: khi ghi âm xong thì không thấy waveform hiển thị, không play được, thời gian ghi là 0, nhưng khi sửa một dòng trong code rồi Ctrl + Z và lưu lại thì mọi thứ lại hoạt động.

Điều này thường là do WaveSurfer không nhận được Blob audio đúng lúc hoặc không được trigger lại để load sau khi ghi âm.

Nguyên nhân có thể:

Trong hàm stopRecording, bạn tạo một Blob từ audioChunks ngay khi sự kiện "stop" được gọi, nhưng audioChunks được cập nhật qua setAudioChunks() vốn là bất đồng bộ (asynchronous) trong React. Do đó, vào thời điểm stop chạy, audioChunks chưa chứa đủ dữ liệu (hoặc là rỗng).

Cách sửa:

Thay vì rely vào state audioChunks, hãy lưu trữ chúng trong một biến tham chiếu (useRef), để đảm bảo bạn có tất cả dữ liệu ngay lúc stop:

1. Thêm audioChunksRef:

const audioChunksRef = useRef([]);

2. Trong startRecording, reset audioChunksRef:

audioChunksRef.current = [];

3. Trong dataavailable, push trực tiếp:

mediaRecorder.addEventListener("dataavailable", (event) => {
    if (event.data.size > 0) {
        audioChunksRef.current.push(event.data);
    }
});

4. Trong stop, dùng audioChunksRef.current:

mediaRecorder.addEventListener("stop", () => {
    const audioBlob = new Blob(audioChunksRef.current, { type: "audio/wav" });
    const url = URL.createObjectURL(audioBlob);
    setAudioUrl(url);
    stream.getTracks().forEach(track => track.stop());
});



⸻

Tóm lại:
	•	Tránh dùng setState để lưu audioChunks vì nó không cập nhật kịp lúc khi bạn cần.
	•	Dùng useRef để có quyền truy cập tức thời vào mảng dữ liệu âm thanh.
	•	Sau đó, audioUrl thay đổi sẽ trigger wavesurfer.load(audioUrl) đúng lúc và waveform sẽ hiển thị.

Bạn có muốn mình sửa trực tiếp đoạn mã đó cho bạn luôn không?



